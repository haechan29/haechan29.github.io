---
title: Context Switching
layout: default
parent: Process, Thread
grand_parent: OS
nav_order: 1.1
---

## 스레드의 컨텍스트 스위칭 비용은 왜 프로세스보다 저렴할까?
### 컨텍스트 스위칭의 원리
현재 실행 중인 프로세스(또는 스레드)를 일시 중단하고 다른 프로세스(또는 스레드)를 실행한다. 이 과정에서 운영체제는 현재 실행 상태(컨텍스트)를 저장하고, 다음에 실행할 프로세스의 상태를 불러온다.<br/>

1. [인터럽트] [1] 또는 시스템 콜: 현재 프로세스의 실행을 중단시키는 이벤트가 발생. Ex. 타이머 인터럽트, I/O 요청 완료, 우선순위에 의한 선점 등.<br/>
2. 컨텍스트 저장: CPU는 현재 프로세스(또는 스레드)의 상태를 PCB(또는 TCB)에 저장한다.<br/>
3. 스케줄링: 운영체제의 스케줄러가 다음에 실행할 프로세스를 결정한다.<br/>
4. 컨텍스트 복원: 선택된 프로세스(또는 스레드)의 PCB(또는 TCB)에서 저장된 상태를 CPU에 복원한다.<br/>

### PCB와 TCB
프로세스(또는 스레드)는 PCB(또는 TCB)에 상태 정보를 저장한다.<br/>
- 공통 요소: 식별자<sup>1</sup>, 상태, PC 레지스터<sup>2</sup>, 레지스터 값<sup>3</sup>.<br/>
- 차별 요소: 프로세스는 메모리 관리 정보<sup>4</sup>를, 스레드는 스택 포인터<sup>4</sup>를 저장한다.<br/>

### [프로세스와 스레드의 상태] [1]
- 생성(New): 프로세스가 생성되고 초기화되는 단계. 이때 프로세스는 자원을 할당받기 위해 대기하는 상태이다.<br/>
- 준비(Ready): 프로세스가 실행을 위해 필요한 모든 자원을 할당받고 CPU 할당을 기다리는 상태.<br/>
- 실행(Running): 프로세스가 CPU를 할당받고 실제로 명령어들을 실행하는 상태.<br/>
- 대기(Blocked): 프로세스가 입출력 작업과 같이 비동기 이벤트의 완료를 기다리는 상태. 필요한 작업이 완료되면 준비 상태로 다시 전환되어 CPU 할당을 기다린다.<br/>
- 종료(Terminated): 프로세스가 모든 작업을 완료하고 운영체제에 의해 종료 처리되는 상태.<br/>
- 보류 준비(Suspended Ready): 프로세스는 실행을 위해 준비가 되었으나, 메모리가 스왑 아웃된 상태.<br/>
- 보류 대기(Suspended Blocked): 프로세스가 입출력 작업과 같은 이유로 실행을 일시 중지해야 하며, 동시에 메모리가 스왑 아웃된 상태.<br/>

### 스레드가 프로세스보다 컨텍스트 스위칭에 유리한 이유
1. 적은 자원 공유: 스레드들은 메모리 공간을 대부분 공유하므로 컨텍스트 스위칭 시 변경 사항이 적다.<br/>
2. 높은 캐시 효율성: 각각의 프로세스는 독립된 메모리 공간을 이용하므로 컨텍스트 스위칭 시 캐시 미스가 많다.<br/>

<br/>

<sup>1</sup>식별자: 프로세스(또는 스레드)의 고유 번호.<br/>
<sup>2</sup>PC 레지스터: 다음에 실행할 명령어의 주소를 저장한다.<br/>
<sup>3</sup>레지스터 값: CPU 레지스터의 현재 값들.<br/>
<sup>4</sup>메모리 관리 정보: 페이지 테이블, 세그먼트 테이블과 같은 메모리 주소 변환 정보 및 메모리 한계.<br/>
<sup>5</sup>스택 포인터: 스레드의 함수 호출과 지역 변수에 사용되는 스택의 주소.<br/>

[1]: interrupt.html
[2]: https://velog.io/@mingadinga_1234/프로세스란-프로세스의-상태